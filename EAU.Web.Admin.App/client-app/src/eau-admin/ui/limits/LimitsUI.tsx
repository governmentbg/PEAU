import { ObjectHelper } from 'cnsys-core';
import { AsyncUIProps, BaseProps, withAsyncFrame } from 'cnsys-ui-react';
import { EAUBaseComponent, NotificationPanel, NotificationType, Pagination, ValidationSummaryErrors } from 'eau-core';
import { action, observable, runInAction } from 'mobx';
import { observer } from 'mobx-react';
import React from 'react';
import { DataServiceLimit, DataServiceLimitsSearchCriteria } from '../../models/ModelsAutoGenerated';
import { ServiceLimitsDataService } from '../../services/ServiceLimitsDataService';
import LimitsResultsUI from './LimitsResultsUI';
import LimitsSearchUI from './LimitsSearchUI';
import CardFooterUI from '../common/CardFooterUI';

interface LimitsProps extends BaseProps, AsyncUIProps {
}

@observer class LimitsUIImpl extends EAUBaseComponent<LimitsProps, DataServiceLimitsSearchCriteria>{

    private limitsDataService: ServiceLimitsDataService;

    @observable private limits: DataServiceLimit[];
    @observable isLoaded: boolean;
    @observable isChangedActivity = null;
    @observable isUpdated = false;

    constructor(props: LimitsProps) {
        super(props);

        this.funcBinds();
        this.init();
    }

    @action private init() {
        this.isUpdated = false;
        this.limitsDataService = new ServiceLimitsDataService();
        this.isLoaded = false;
        this.model = new DataServiceLimitsSearchCriteria();
    }

    private funcBinds() {
        this.onSearch = this.onSearch.bind(this);
        this.onClear = this.onClear.bind(this);
        this.onPageChange = this.onPageChange.bind(this);
        this.onChangeStatus = this.onChangeStatus.bind(this);
        this.onSave = this.onSave.bind(this);
        this.onCancelChanges = this.onCancelChanges.bind(this);
    }

    render() {
        let dataResult: any = null;

        if (this.isLoaded) {

            if (this.limits && this.limits.length > 0) {
                dataResult = <div className="card">
                        <div className="card-body">
                    {this.isUpdated && <div className="alert alert-success"><p>{this.getResource("GL_UPDATE_OK_I")}</p></div>}
                    {!ObjectHelper.isNullOrUndefined(this.isChangedActivity) && <div className="alert alert-success"><p>{this.isChangedActivity ? this.getResource("GL_ACTIVE_OK_I") : this.getResource("GL_DEACTIVE_OK_I")}</p></div>}

                    <Pagination activePage={this.model.page} count={this.model.count} pagesCount={this.model.getPagesCount()} maxVisiblePage={10} size="sm" onSelect={this.onPageChange} aditionalCssClass="pagination-container--page-top" />
                    {<LimitsResultsUI limits={this.limits} onChangeStatus={this.onChangeStatus} onSave={this.onSave} onCancelChanges={this.onCancelChanges} />}
                    <Pagination activePage={this.model.page} count={this.model.count} pagesCount={this.model.getPagesCount()} maxVisiblePage={10} size="sm" onSelect={this.onPageChange} />
                </div>
                </div>
            } else {

                dataResult = (<div className="card">
                    <div className="col-12">
                        <NotificationPanel notificationType={NotificationType.Info} text={this.getResource("GL_NO_DATA_FOUND_L")} />
                    </div>
                </div>);
            }
        }

        return <>
            <div className="card">
                <div className="col-12">
                    <ValidationSummaryErrors asyncErrors={this.props.asyncErrors} />
                </div>
                    {<LimitsSearchUI onSearchCallback={this.onSearch} onClearCallback={this.onClear}  {...this.bind(x => x, "DataServiceLimitsSearchCriteria")} />}
                <CardFooterUI onClear={this.onClear} onSearch={this.onSearch} />
            </div>
            {dataResult}
        </>
    }

    @action private onCancelChanges(model, initialLimit) {
        this.isUpdated = false;
        model.copyFrom(initialLimit);
    }

    @action private onSave(model) {
        this.isChangedActivity = null;
        this.isUpdated = false;

        this.props.registerAsyncOperation(
            this.limitsDataService.updateServiceLimit(model)
                .then(() => this.isUpdated = true)
        );
    }

    onChangeStatus(serviceLimit) {

        this.isUpdated = false;

        this.props.registerAsyncOperation(
            serviceLimit.status ?
                this.limitsDataService.deactivateServiceLimit(serviceLimit)
                    .then(() => {
                        runInAction.bind(this)(() => {
                            serviceLimit.status = 0
                            this.isChangedActivity = serviceLimit.status;
                        });
                    })
                :
                this.limitsDataService.activateServiceLimit(serviceLimit)
                    .then(() => {
                        runInAction.bind(this)(() => {
                            serviceLimit.status = 1;
                            this.isChangedActivity = serviceLimit.status;
                        });
                    })
        )

    }

    @action private onPageChange(page: any): void {
        this.isUpdated = false;
        this.isChangedActivity = null;
        this.model.page = page;
        this.props.registerAsyncOperation(this.searchServiceLimits());
    }

    @action private onSearch() {
        this.isUpdated = false;
        this.isChangedActivity = null;
        this.model.page = 1;
        this.props.registerAsyncOperation(this.searchServiceLimits());
    }

    private onClear() {
        this.init();
    }

    @action private searchServiceLimits() {

        this.isLoaded = false;
        this.isChangedActivity = null;

        return this.limitsDataService.getServiceLimits(this.model).then(result => {
            this.limits = result;
        })
            .finally(() => {
                this.isLoaded = true;
            })
    }
}

export const LimitsUI = withAsyncFrame(LimitsUIImpl, false);