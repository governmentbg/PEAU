import * as React from "react";
import { AsyncUIProps, BaseProps, withAsyncFrame } from "cnsys-ui-react";
import { observer } from "mobx-react";
import { EAUBaseComponent, Label, Language, ValidationSummaryErrors } from "eau-core";
import { action, observable, runInAction } from "mobx";
import { LabelSearchCriteria, LabelTranslation } from "../../../models/ModelsAutoGenerated";
import TranslationLangUI from "../../common/TranslationLangUI";
import { NomenclaturesDataService } from "../../../services/NomenclaturesDataService";
import { LabelTranslationsSearchFormUI } from "./LabelTranslationsSearchFormUI";
import { LabelTranslationSearchResultsUI } from "./LabelTranslationsSearchResultsUI";
import { ObjectHelper } from "cnsys-core/common";
import { LabelTranslationI18nVM } from "../../../models/LabelTranslationI18nVM";
import { LabelTranslationI18nVMValidator } from "../../../validations/LabelTranslationI18nVMValidator";



interface LabelTranslationsUIProps extends BaseProps, AsyncUIProps {
}

@observer
class LabelTranslationsUIImpl extends EAUBaseComponent<LabelTranslationsUIProps, LabelSearchCriteria> {

    @observable private isLoaded: boolean = false;
    @observable private selectedLanguage;
    @observable private labelItems: Label[] = [];
    @observable private labelItemsForeign: Label[] = [];
    @observable private labelItemsWithTranslation: LabelTranslationI18nVM[] = [];
    @observable private onlyLabelsWithoutTranslation: boolean = false;

    private nomenclatureDataService: NomenclaturesDataService;
    private validator: LabelTranslationI18nVMValidator;

    constructor(props: LabelTranslationsUIProps) {
        super(props);
        this.nomenclatureDataService = new NomenclaturesDataService();

        this.searchLabels = this.searchLabels.bind(this);
        this.searchForeignLabels = this.searchForeignLabels.bind(this);
        this.onLangSelect = this.onLangSelect.bind(this);
        this.showLabelsWithoutTranslation = this.showLabelsWithoutTranslation.bind(this);
        this.saveTranslation = this.saveTranslation.bind(this);
        this.validator = new LabelTranslationI18nVMValidator();
        this.model = new LabelSearchCriteria();
        this.model.count = this.labelItems.length;
        this.searchLabels(this.model);
    }

    render() {
        return (
            <>
                <TranslationLangUI onLangSelect={this.onLangSelect} loadCurrentLanguage={(lang) => { this.onLangSelect(lang); }} />
                <div className="card">
                    <div className="col-12">
                        <ValidationSummaryErrors asyncErrors={this.props.asyncErrors} />
                    </div>
                    <LabelTranslationsSearchFormUI
                        {...this.bind(model => model, "LabelSearchCriteria")}
                        searchLabelsFunc={this.searchLabels}
                        showLabelsWithoutTranslationFunc={this.showLabelsWithoutTranslation} />
                </div>
                {this.isLoaded ?
                    ((this.labelItemsWithTranslation && this.labelItemsWithTranslation.length > 0) ?
                        <LabelTranslationSearchResultsUI
                            {...this.bind(model => model, "LabelSearchCriteria")}
                            selectedLanguage={this.selectedLanguage}
                            labelsList={this.labelItemsWithTranslation}
                            searchLabelsFunc={this.searchLabels}
                            saveTranslationFunc={this.saveTranslation}
                        />
                        :
                        <div className="alert alert-dismissible alert-warning fade show">
                            <p>{this.getResource("GL_NO_DATA_FOUND_L")}</p>
                        </div>)
                    : null
                }

            </>
        );
    }


    private onLangSelect(lang: Language) {
        this.selectedLanguage = lang;
        this.searchForeignLabels(lang);
    }

    private showLabelsWithoutTranslation(withoutTranslation: boolean) {
        if (withoutTranslation) {
            this.onlyLabelsWithoutTranslation = true;
        } else {
            this.onlyLabelsWithoutTranslation = false;
        }
        this.searchLabels(this.model);
    }

    private searchLabels(searchCriteria: LabelSearchCriteria) {
        this.isLoaded = false;
        if (!this.onlyLabelsWithoutTranslation) {
            this.props.registerAsyncOperation(this.nomenclatureDataService.searchLabels(searchCriteria).then((labels) => {
                runInAction(() => {
                    this.labelItems = labels;
                    this.createListOfTranslation();
                    this.isLoaded = true;
                });
            }));
        } else {
            this.props.registerAsyncOperation(this.nomenclatureDataService.searchLabels(searchCriteria, this.selectedLanguage ? this.selectedLanguage.code : "en", true).then((labels) => {
                runInAction(() => {
                    this.labelItems = labels;
                    this.createListOfTranslation();
                    this.isLoaded = true;
                });
            }));
        }
    }

    @action private searchForeignLabels(language?: Language) {
        let searchCriteria = new LabelSearchCriteria();
        searchCriteria.pageSize = Number.MAX_VALUE;
        searchCriteria.count = Number.MAX_VALUE;
        this.isLoaded = false;
        this.props.registerAsyncOperation(this.nomenclatureDataService.searchLabels(searchCriteria, language.code, false, true).then((translations) => {
            runInAction(() => {
                this.labelItemsForeign = translations;
                this.createListOfTranslation();
                this.isLoaded = true;
            });
        }));
    }

    @action private createListOfTranslation() {
        this.labelItemsWithTranslation = [];
        
        this.labelItems.forEach((label) => {
            let translation = new LabelTranslationI18nVM();
            translation.labelID = label.labelID;
            translation.labelCode = label.code;
            translation.description = label.description;
            translation.languageCode = this.selectedLanguage.code;
            translation.languageName = this.selectedLanguage.name;
            translation.bgValue = label.value;
          
            let translatedLabel = this.labelItemsForeign.filter(l => l.code == label.code);
            
            translation.isTranslated = !ObjectHelper.isArrayNullOrEmpty(translatedLabel) ? translatedLabel[0].isTranslated : false;
            translation.value = translation.isTranslated ? translatedLabel[0].value : "";

            this.labelItemsWithTranslation.push(translation);
        });
    }

    @action private saveTranslation(translation: LabelTranslationI18nVM) {
        if (this.validator.validate(translation)) {
            
            return this.nomenclatureDataService.getLanguages().then((languages) => {
                languages = languages.filter((l) => {
                    return l.code == translation.languageCode;
                });

                let labelTranslation: LabelTranslation = new LabelTranslation();
                labelTranslation.labelID = translation.labelID;
                labelTranslation.languageID = languages[0].languageID;
                labelTranslation.value = translation.value;
                labelTranslation.description = translation.description;

                if (translation.isTranslated) {
                    this.nomenclatureDataService.updateLabelTranslation(labelTranslation, translation.languageCode)
                    
                    let resultLabelItemsForeign = this.labelItemsForeign.find( ({ labelID }) => labelID === translation.labelID);
                    resultLabelItemsForeign.value = translation.value;

                    let resultLabelItemsWithTranslation = this.labelItemsWithTranslation.find( ({ labelID }) => labelID === translation.labelID);
                    resultLabelItemsWithTranslation.value = translation.value;

                    

                } else {
                    this.nomenclatureDataService.addLabelTranslation(labelTranslation, translation.languageCode)

                    let labelItemsForeignObj = new Label();
                    labelItemsForeignObj.languageCode = translation.languageCode;
                    labelItemsForeignObj.value = translation.value;
                    labelItemsForeignObj.labelID = translation.labelID;
                    labelItemsForeignObj.isTranslated = true;
                    labelItemsForeignObj.description = translation.description;
                    labelItemsForeignObj.code = translation.labelCode;

                    this.labelItemsForeign.push(labelItemsForeignObj);

                    let resultLabelItemsWithTranslation = this.labelItemsWithTranslation.find( ({ labelID }) => labelID === translation.labelID);
                    resultLabelItemsWithTranslation.isTranslated = true;
        
                }

                

                

            });
        } else {
            return Promise.resolve();
        }
    }
}

export const LabelTranslationsUI = withAsyncFrame(LabelTranslationsUIImpl, false);