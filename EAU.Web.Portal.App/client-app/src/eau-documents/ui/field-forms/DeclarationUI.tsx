import { ObjectHelper } from "cnsys-core";
import { BaseProps, ViewMode } from "cnsys-ui-react";
import { Declaration, EAUBaseComponent } from "eau-core";
import { action } from "mobx";
import React from "react";
import { DeclarationVM } from "../../models/ModelsAutoGenerated";
import { ApplicationFormManagerProps, withDocumentFormManager } from "../document-forms/DocumentFormManagerProvider";
import { DeclarationVMValidator } from '../../validations/DeclarationVMValidator';

interface DeclarationUIProps extends BaseProps, ApplicationFormManagerProps {
}

class DeclarationUIImpl extends EAUBaseComponent<DeclarationUIProps, DeclarationVM>{

    private id: string;
    private declarationNom: Declaration;

    constructor(props: DeclarationUIProps) {
        super(props);

        //Bind
        this.handleCheckBoxChange = this.handleCheckBoxChange.bind(this);
        this.componentDidUpdate = this.componentDidUpdate.bind(this);

        //Init
        this.id = ObjectHelper.newGuid();

        if (this.props && this.props.documentFormManager && this.props.documentFormManager.service)
            this.declarationNom = this.props.documentFormManager.service ? this.props.documentFormManager.service.declarations.filter(d => d.code == this.model.code)[0] : null;
        else
            this.declarationNom = undefined;
    }

    renderEdit(): JSX.Element {

        if (this.declarationNom) {
            let hasModelError: boolean = this.model.getPropertyErrors('isDeclarationFilled').length > 0;

            return (
                <>
                    <div className="custom-control custom-checkbox disabled">
                        <input id={this.id}
                            className={hasModelError ? "custom-control-input input-error" : "custom-control-input"}
                            type="checkbox"
                            onChange={this.handleCheckBoxChange}
                            value={this.model.isDeclarationFilled ? 1 : 0}
                            checked={this.model.isDeclarationFilled}
                            required={this.declarationNom.isRquired ? true : false} />
                        <label htmlFor={this.id} className="custom-control-label">
                            <div className={this.declarationNom.isRquired ? "required-field" : ""}>
                                {this.rawHtml(this.model.content)}
                            </div>
                        </label>
                        {this.propertyErrorsDispleyFor(m => m.isDeclarationFilled)}
                    </div>
                    {this.declarationNom.isAdditionalDescriptionRequired && this.model.isDeclarationFilled &&
                        <div className="align-to-check-box" id={this.id}>
                        <label htmlFor="furtherDescriptionFromDeclarer" className="form-control-label required-field">{this.getResourceByProperty(m => m.furtherDescriptionFromDeclarer)} </label>
                            {<>{this.textAreaFor(m => m.furtherDescriptionFromDeclarer, null, 3, null, null)}</>}
                        </div>
                    }
                </>

            );
        }

        return null;
    };

    renderDisplay(): JSX.Element {
        if (this.model) {
            return (
                <>
                    {this.model.isDeclarationFilled === true || (this.declarationNom && this.declarationNom.isRquired)
                        ? <>
                            {this.rawHtml(this.model.content, { "aria-hidden": "true" })}
                            {this.propertyErrorsDispleyFor(m => m.isDeclarationFilled)}
                            {this.model.furtherDescriptionFromDeclarer || (this.declarationNom && this.declarationNom.isAdditionalDescriptionRequired)
                                ? <>
                                    <h4 className="form-control-label">{this.getResourceByProperty(m => m.furtherDescriptionFromDeclarer)}</h4>
                                    {this.textDisplayFor(m => m.furtherDescriptionFromDeclarer)}
                                </>
                                : null}
                        </> : null}
                </>
            );
        }
    }

    componentDidUpdate(): void {
        if (this.props.viewMode == ViewMode.Edit && this.model.getPropertyErrors('isDeclarationFilled').length > 0) {
            let firstErrorElement = $("input[type='text'].input-error, input[type='checkbox'].input-error, input[type='radio'].input-error, select.input-error, textarea.input-error").first();

            if (firstErrorElement.length == 1 && firstErrorElement.attr('id') == this.id) {
                firstErrorElement.focus();
            }
        }
    }

    @action private handleCheckBoxChange(e: any) {
        this.model.isDeclarationFilled = !this.model.isDeclarationFilled;
        this.props.documentFormManager.declarationMapper(this.model.code, this.model.isDeclarationFilled);

        let validator: DeclarationVMValidator = new DeclarationVMValidator();
        validator.setValidationContext({ documentFormManager: this.props.documentFormManager });

        validator.validate(this.model);
    }
}

export const DeclarationUI = withDocumentFormManager(DeclarationUIImpl);